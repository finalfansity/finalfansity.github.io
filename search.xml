<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2020/06/25/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>mysql入门-01</title>
    <url>/2020/06/25/mysql%E5%85%A5%E9%97%A8-01/</url>
    <content><![CDATA[<h1 id="mysql入门"><a href="#mysql入门" class="headerlink" title="mysql入门"></a>mysql入门</h1><h2 id="客户端连接mysql"><a href="#客户端连接mysql" class="headerlink" title="客户端连接mysql"></a>客户端连接mysql</h2><p>​        默认情况下，mysql监听的端口为3306，因此需要指定3306；登陆还需要登陆mysql服务的账号和密码，初始情况下未创建任何其他非root账号，所以使用root账号进行登录，密码为指定的密码，若已经更改过密码，使用修改后的密码。</p>
<a id="more"></a>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 命令格式</span></span><br><span class="line">mysql -h localhost -P 3306 -u&lt;username&gt; -p&lt;password&gt;</span><br><span class="line"></span><br><span class="line">mysql --host=localhost --port=3306 --user=root --password=&lt;password&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在使用过程中不要将密码直接在命令行输入,使用以下方式</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> mysql --host=localhost --port=3306 --user=root --password</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Enter Password:</span></span><br></pre></td></tr></table></figure>

<h2 id="数据库创建"><a href="#数据库创建" class="headerlink" title="数据库创建"></a>数据库创建</h2><p>​        在任何关系型数据库管理系统（RDBMS）的内部，数据都是以行来进行存储，每一行中也包含着许多列。表中容纳的列必须在表定义的时候进行定义，虽然可以随时修改表的定义，但是在进行表结构进行调整时，整个表都需要进行重新构建，在一定的情形下，表在进行修改时是不可用的（在操作大表时尤为要注意）。</p>
<p>​        数据库是众多的数据表组成的，数据库服务器（mysql）又可以包含许多的数据库</p>
<ul>
<li>任何操作（创建，修改或者删除数据库对象，ps 对数据库和数据表进行创建，修改和删除），都被称作<strong>数据定义语言DDL</strong>操作。</li>
</ul>
<p>​        数据按照某种蓝图组织构建数据库，这种数据的组织形式被称为<strong>schema</strong>。在mysql中schema可以简单认为schema和database是相同的，但是在使用其他的关系型数据库时需要注意，各自具体的schema的定义。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">In MySQL, physically, a schema is synonymous with a database. You can</span><br><span class="line">substitute the keyword SCHEMA instead of DATABASE in MySQL SQL syntax,</span><br><span class="line">for example using CREATE SCHEMA instead of CREATE DATABASE.</span><br></pre></td></tr></table></figure>

<h3 id="命令行创建数据库"><a href="#命令行创建数据库" class="headerlink" title="命令行创建数据库"></a>命令行创建数据库</h3><p>连接到mysql服务并创建数据库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> mysql -uroot -p</span></span><br><span class="line">Enter Password:</span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> CREATE DATABASE mydb;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> CREATE DATABASE `my.database`;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> （`）用于引用标识符，例如数据库和表名。当数据库名称中含有特殊字符时，需要使用`来进行处理。</span></span><br></pre></td></tr></table></figure>

<p>切换不同的数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; USE mydb;</span><br><span class="line">mysql&gt; USE &#96;my.database&#96;</span><br></pre></td></tr></table></figure>

<p>查看目前位于哪个数据库下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT DATABASE();</span><br><span class="line">+------------+</span><br><span class="line">| DATABASE() |</span><br><span class="line">+------------+</span><br><span class="line">| mydb       |</span><br><span class="line">+------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>查看目前账号有权限访问的数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW DATABASES;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mydb               |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">| test               |</span><br><span class="line">+--------------------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>数据库的创建会在对应的数据目录下再创建一个对应目录。默认安装的mysql的数据目录是在/var/lib/mysql，如果有修改的话，可以到对应的mysql的配置文件里查找datadir字段来查看目录，或者可以在mysql服务内查看。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#39;%datadir%&#39;;</span><br><span class="line"></span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| Variable_name | Value           |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| datadir       | &#x2F;var&#x2F;lib&#x2F;mysql&#x2F; |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> ls /var/lib/mysql</span></span><br><span class="line"></span><br><span class="line">drwxr-x--- 2 mysql mysql     4096 Jun 21 15:18 mydb</span><br><span class="line">drwxr-x--- 2 mysql mysql     4096 May 28 14:09 mysql</span><br><span class="line">drwxr-x--- 2 mysql mysql     4096 May 28 14:09 performance_schema</span><br><span class="line">drwxr-x--- 2 mysql mysql     4096 May 28 14:09 sys</span><br><span class="line">drwxr-x--- 2 mysql mysql     4096 Jun  6 15:24 test</span><br></pre></td></tr></table></figure>



<h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><p>定义表中的列时需要指定列的名称，数据类型和默认字段。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">数字：	TINYINT		<span class="type">SMALLINT</span>	MEDIUMINT		<span class="type">INT</span>		<span class="type">BIGINT</span>		<span class="type">BIT</span></span><br><span class="line">浮点：	<span class="type">DECIMAL</span>		<span class="type">FLOAT</span>			<span class="type">DOUBLE</span></span><br><span class="line">字符串：	<span class="type">CHAR</span>	VARHCHAR	BINARY	VARBINARY		BLOG	<span class="type">TEXT</span>	ENUM	<span class="keyword">SET</span></span><br><span class="line">Spatial</span><br><span class="line"><span class="type">json</span>类型</span><br></pre></td></tr></table></figure>

<h3 id="命令行操作"><a href="#命令行操作" class="headerlink" title="命令行操作"></a>命令行操作</h3><ul>
<li><strong>句点符号</strong> 可以用来表示库.表的结构，如果已经连接到数据库的话，则可以直接使用表名，不必带库名。</li>
<li>IF NOT EXISTS  表示如果已经有了一个同名的表，在创建语句中有这个字段时，数据库不会创建这个表，只会返回一个警告。</li>
<li>id  被定义为一个整型的数据</li>
<li>AUTO_INCREMENT  自动生成递增序列</li>
<li>PRIMARY_KEY  每行都有一个非空的UNIQUE列标识，只有一列应该在表中定义。如果表中包含AUTO_INCREMENT列，则它会被视作 PRIMARY_KEY</li>
<li>first_name, last_name，country 包含字符串，因此被定义为varchar</li>
<li>engine  与列的定义一起，还应当制定存储引擎。常见的存储引擎包括： InnoDB  MyISAM FEDERATED  BLACKHOLE  CSV 和MEMARY</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; CREATE TABLE IF NOT EXISTS &#96;mydb&#96;.&#96;people&#96; (</span><br><span class="line">&#96;id&#96; int unsigned AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">&#96;first_name&#96; varchar(20),</span><br><span class="line">&#96;last_name&#96;  varchar((20),</span><br><span class="line">&#96;conuntry&#96; varchar(20),</span><br><span class="line">) ENGINE&#x3D;InnoDB;</span><br></pre></td></tr></table></figure>

<p>查看支持的存储引擎</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW ENGINES;</span><br><span class="line">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span><br><span class="line">| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |</span><br><span class="line">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span><br><span class="line">| FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |</span><br><span class="line">| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |</span><br><span class="line">| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |</span><br><span class="line">| PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |</span><br><span class="line">| MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |</span><br><span class="line">| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |</span><br><span class="line">| BLACKHOLE          | YES     | &#x2F;dev&#x2F;null storage engine (anything you write to it disappears) | NO           | NO   | NO         |</span><br><span class="line">| CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |</span><br><span class="line">| ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |</span><br><span class="line">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>查看当前库内的表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW TABLES;</span><br><span class="line">+----------------+</span><br><span class="line">| Tables_in_mydb |</span><br><span class="line">+----------------+</span><br><span class="line">| contacts       |</span><br><span class="line">| employee       |</span><br><span class="line">+----------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>查看表结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 方法1</span><br><span class="line">mysql&gt; DESC contacts;</span><br><span class="line">+-------+-------------+------+-----+---------+----------------+</span><br><span class="line">| Field | Type        | Null | Key | Default | Extra          |</span><br><span class="line">+-------+-------------+------+-----+---------+----------------+</span><br><span class="line">| id    | int         | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| name  | varchar(50) | YES  |     | NULL    |                |</span><br><span class="line">| sex   | tinyint     | YES  |     | 1       |                |</span><br><span class="line">| phone | varchar(20) | YES  |     | NULL    |                |</span><br><span class="line">+-------+-------------+------+-----+---------+----------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># 方法2</span><br><span class="line">mysql&gt; SHOW CREATE TABLE contacts;</span><br><span class="line">+----------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Table    | Create Table                                                                                                                                                                                                                                                               |</span><br><span class="line">+----------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| contacts | CREATE TABLE &#96;contacts&#96; (</span><br><span class="line">  &#96;id&#96; int NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;name&#96; varchar(50) DEFAULT NULL,</span><br><span class="line">  &#96;sex&#96; tinyint DEFAULT &#39;1&#39;,</span><br><span class="line">  &#96;phone&#96; varchar(20) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;4 DEFAULT CHARSET&#x3D;utf8mb4 COLLATE&#x3D;utf8mb4_0900_ai_ci |</span><br><span class="line">+----------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>克隆表结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE new_contacts LIKE contacts;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line"># 查看新的表结构</span><br><span class="line">mysql&gt; desc new_contacts;</span><br><span class="line">+-------+-------------+------+-----+---------+----------------+</span><br><span class="line">| Field | Type        | Null | Key | Default | Extra          |</span><br><span class="line">+-------+-------------+------+-----+---------+----------------+</span><br><span class="line">| id    | int         | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| name  | varchar(50) | YES  |     | NULL    |                |</span><br><span class="line">| sex   | tinyint     | YES  |     | 1       |                |</span><br><span class="line">| phone | varchar(20) | YES  |     | NULL    |                |</span><br><span class="line">+-------+-------------+------+-----+---------+----------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>shell脚本练习</title>
    <url>/2020/06/27/shell%E8%84%9A%E6%9C%AC%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="shell脚本练习"><a href="#shell脚本练习" class="headerlink" title="shell脚本练习"></a>shell脚本练习</h1><p>1、编写脚本/root/bin/createuser.sh，实现如下功能：使用一个用户名做为参 数，如果指定参数的用户存在，就显示其存在，否则添加之；显示添加的用户 的id号等信息 <a id="more"></a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">read -p "please input your username: " n</span><br><span class="line">useradd $n &amp;&gt; /dev/null</span><br><span class="line">if [ "$?" == "0" ]</span><br><span class="line">        then</span><br><span class="line">                echo "user info:  `cat /etc/passwd | grep -E "\&lt;^$n\&gt;"`"</span><br><span class="line">        else</span><br><span class="line">        echo "user already exists"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>2、编写脚本/root/bin/yesorno.sh，提示用户输入yes或no,并判断用户输入的 是yes还是no,或是其它信息.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">read -p "please input yes or no: " n</span><br><span class="line">        case $n in</span><br><span class="line">                [Yy][Ee][sS]|[Yy])</span><br><span class="line">                        echo "you input is yes"</span><br><span class="line">                         ;;</span><br><span class="line">                [Nn][oO]|[Nn])</span><br><span class="line">                        echo "you input is no"</span><br><span class="line">                         ;;</span><br><span class="line">                *)</span><br><span class="line">                 echo "you input is other info"</span><br><span class="line">                          ;;</span><br><span class="line">        esac</span><br></pre></td></tr></table></figure>




<p>3、编写脚本/root/bin/filetype.sh,判断用户输入文件路径，显示其文件类型 （普通，目录，链接，其它文件类型） </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">read -p "please input file path: " n</span><br><span class="line">if [ -f "$n" ]</span><br><span class="line">        then</span><br><span class="line">                echo "$n is 普通文件";</span><br><span class="line">        elif [ -b "$n" ]</span><br><span class="line">        then</span><br><span class="line">                echo "$n is 块设备文件";</span><br><span class="line">        elif [ -c "$n" ]</span><br><span class="line">        then</span><br><span class="line">                echo "$n is 字符设备文件";</span><br><span class="line">        elif [ -h "$n" ]</span><br><span class="line">        then</span><br><span class="line">                echo "$n is 符号链接文件"</span><br><span class="line">        elif [ -d "$n" ]</span><br><span class="line">        then</span><br><span class="line">                echo "$n is 目录文件";</span><br><span class="line">        elif [ -p "$n" ]</span><br><span class="line">        then</span><br><span class="line">                echo "$n is 管道文件";</span><br><span class="line">        elif [ -s "$n" ]</span><br><span class="line">        then</span><br><span class="line">                echo "$n is 套接字文件";</span><br><span class="line">        else</span><br><span class="line">                echo "$n unknown"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>4、编写脚本/root/bin/checkint.sh,判断用户输入的参数是否为正整数 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">read -p "please input your charactor: " n</span><br><span class="line">m=`echo $n | sed -n -r 's/[0-9]//gp'`</span><br><span class="line">if [ ! "n$m" == "n" ]</span><br><span class="line">        then</span><br><span class="line">                echo "please restart input"     </span><br><span class="line">        elif [ "$n" == "0" ]</span><br><span class="line">                then</span><br><span class="line">                        echo "your input is 0"</span><br><span class="line">else</span><br><span class="line">        echo "your input is 正整数"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>5、判断/var/目录下所有文件的类型 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">	for n in /var/*</span><br><span class="line">	   do</span><br><span class="line">	        if [ -f "$n" ]</span><br><span class="line">	        then</span><br><span class="line">	                echo "$n is 普通文件";</span><br><span class="line">	        elif [ -b "$n" ]</span><br><span class="line">	        then</span><br><span class="line">	                echo "$n is 块设备文件";</span><br><span class="line">	        elif [ -c "$n" ]</span><br><span class="line">	        then</span><br><span class="line">	                echo "$n is 字符设备文件";</span><br><span class="line">	        elif [ -h "$n" ]</span><br><span class="line">	        then</span><br><span class="line">	                echo "$n is 符号链接文件"</span><br><span class="line">	        elif [ -d "$n" ]</span><br><span class="line">	        then</span><br><span class="line">	                echo "$n is 目录文件";</span><br><span class="line">	        elif [ -p "$n" ]</span><br><span class="line">	        then</span><br><span class="line">	                echo "$n is 管道文件";</span><br><span class="line">	        elif [ -s "$n" ]</span><br><span class="line">	        then</span><br><span class="line">	                echo "$n is 套接字文件";</span><br><span class="line">	        else</span><br><span class="line">	                echo "$n unknown"</span><br><span class="line">	        fi</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>



<p>6、添加10个用户user1-user10，密码为指定字符 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">for n in user&#123;1..10&#125;</span><br><span class="line">        do</span><br><span class="line">        useradd $n</span><br><span class="line">        if [ "$?" = "0" ]</span><br><span class="line">                then</span><br><span class="line">                echo "12345678" | passwd --stdin $n</span><br><span class="line">        else</span><br><span class="line">                echo "用户存在"</span><br><span class="line">        fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>



<p>7、/etc/rc.d/rc3.d目录下分别有多个以K开头和以S开头的文件；分别读取每个文件， 以K开头的输出为文件加stop，以S开头的输出为文件名加start，如K34filename stop  S66filename start </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">for i in /etc/rc.d/rc3.d/[SK]* ;do</span><br><span class="line">if [ $(basename $i | cut -c1) == "K" ] ;then</span><br><span class="line">    echo "`basename $i` stop"</span><br><span class="line">else</span><br><span class="line">    echo "`basename $i` start"</span><br><span class="line">fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>



<p>8、编写脚本，提示输入正整数n的值，计算1+2+…+n的总和 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">read -p "please input num: " n</span><br><span class="line">for (( i=1;i&lt;="$n";i++ ))</span><br><span class="line">        do</span><br><span class="line">        sum=$[$sum+$i]</span><br><span class="line">done</span><br><span class="line">echo $sum</span><br></pre></td></tr></table></figure>



<p>9、计算100以内所有能被3整除的整数之和  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">n=0</span><br><span class="line">for i in &#123;1..100&#125;;</span><br><span class="line">do</span><br><span class="line">        if [ $[$i%3] -eq 0 ]</span><br><span class="line">        then</span><br><span class="line">        n=$[$n+$i]</span><br><span class="line">        fi</span><br><span class="line">done</span><br><span class="line">echo "sum=$n"</span><br></pre></td></tr></table></figure>



<p>10、编写脚本，提示请输入网络地址，如192.168.0.0，判断输入的网段中主机在线状态  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">f=`mktemp /tmp/ping.XXXXXXX`</span><br><span class="line">read -p "please input you want to test: " ip</span><br><span class="line">n=`echo $ip | cut -d'.' -f1-3`</span><br><span class="line">for i in &#123;1..255&#125;</span><br><span class="line">        do</span><br><span class="line">        &#123;       m=$n.$i</span><br><span class="line">                ping -w1 -c1 $m &amp;&gt; /dev/null &amp;&amp; echo "$m is up!" &amp;&amp; echo $m &gt;&gt; $f</span><br><span class="line">        &#125;&amp;</span><br><span class="line">        done</span><br></pre></td></tr></table></figure>



<p>11、打印九九乘法表  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">for i in &#123;1..9&#125;</span><br><span class="line">        do</span><br><span class="line">        for j in $(seq 1 $i) ;do</span><br><span class="line">             echo -ne "$&#123;j&#125;x$&#123;i&#125;=$[i*j]\t"</span><br><span class="line">        done</span><br><span class="line">        echo </span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>12、在/testdir目录下创建10个html文件,文件名格式为数字N（从1到10）加随机8个字 母，如：1AbCdeFgH.html </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">for i in &#123;1..10&#125;</span><br><span class="line">do</span><br><span class="line">        n=`openssl rand -base64 64 | tr -dc '[a-zA-Z]' | head -c8`</span><br><span class="line">        touch /testdir/$i$n.html</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>13、打印等腰三角形 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">until read -p "place input number " line ;do</span><br><span class="line">  if [[ "$line" =~ [0-9]+ ]] ;then</span><br><span class="line">      continue</span><br><span class="line">  fi</span><br><span class="line">done</span><br><span class="line">for i in `seq 1 $line` ;do</span><br><span class="line">     space=$[line-i]</span><br><span class="line">     star=$[2*i-1]</span><br><span class="line">        for j in `seq 1 $space` ; do</span><br><span class="line">             echo -e  " \c"</span><br><span class="line">        done</span><br><span class="line">        for k in `seq 1 $star`; do</span><br><span class="line">             clocr=$[RANDOM%7+31]</span><br><span class="line">             echo -e  "\e[1;$&#123;clocr&#125;m*\e[0m\c"</span><br><span class="line">        done</span><br><span class="line">     echo</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>14、编写脚本，求100以内所有正奇数之和 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">n=0</span><br><span class="line">for i in &#123;1..100&#125;;</span><br><span class="line">do</span><br><span class="line">        if [ $[$i%2] -eq 1 ]</span><br><span class="line">        then</span><br><span class="line">        n=$[$n+$i]</span><br><span class="line">        fi</span><br><span class="line">done</span><br><span class="line">echo "sum=$n"</span><br></pre></td></tr></table></figure>

<p>15、编写脚本，提示请输入网络地址，如192.168.0.0，判断输入的网段中主机 在线状态，并统计在线和离线主机各多少 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">f=`mktemp /tmp/ping.XXXXXXX`</span><br><span class="line">read -p "please input you want to test: " ip</span><br><span class="line">n=`echo $ip | cut -d'.' -f1-3`</span><br><span class="line">for i in &#123;1..255&#125;</span><br><span class="line">        do</span><br><span class="line">        &#123;       m=$n.$i</span><br><span class="line">                ping -w1 -c1 $m &amp;&gt; /dev/null &amp;&amp; &#123; echo "$m is up!"; echo $m &gt;&gt; $f; &#125;</span><br><span class="line">        &#125;&amp;</span><br><span class="line">        done</span><br><span class="line">g=`cat "$f" | wc -l`</span><br><span class="line">j=$[255-$g]</span><br><span class="line">echo "up num: $g; down num: $j"</span><br></pre></td></tr></table></figure>



<p>16、编写脚本，打印九九乘法表 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">for i in &#123;1..9&#125;</span><br><span class="line">        do</span><br><span class="line">        for j in $(seq 1 $i) ;do</span><br><span class="line">             echo -ne "$&#123;j&#125;x$&#123;i&#125;=$[i*j]\t"</span><br><span class="line">        done</span><br><span class="line">        echo </span><br><span class="line">done</span><br></pre></td></tr></table></figure>



<p>17、编写脚本，利用变量RANDOM生成10个随机数字，输出这个10数字，并显 示其中的最大值和最小值 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">let i=0,min=max=$RANDOM</span><br><span class="line">echo "$min "</span><br><span class="line">while [ $i -lt 9  ];do</span><br><span class="line">    ran=$RANDOM</span><br><span class="line">    echo "$ran "</span><br><span class="line">    if [ $ran -ge $max ];then</span><br><span class="line">        let max=ran</span><br><span class="line">    fi</span><br><span class="line">    if [ $ran -le $min ];then</span><br><span class="line">        let min=ran</span><br><span class="line">    fi</span><br><span class="line">    let i+=1</span><br><span class="line">done</span><br><span class="line">echo "max is: $max ,min is: $min"</span><br></pre></td></tr></table></figure>



<p>18、编写脚本，实现打印国际象棋棋盘 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">let x=y=1</span><br><span class="line">h=8</span><br><span class="line">while [ $x -le $h ];do</span><br><span class="line">    while [ $y -le $h ];do</span><br><span class="line">        if [ $[(x+y)%2] -eq 0 ]  ;then</span><br><span class="line">            echo -en "\033[47m  \033[0m"</span><br><span class="line">        else</span><br><span class="line">            echo -en "\033[40m  \033[0m"</span><br><span class="line">        fi</span><br><span class="line">    let y+=1</span><br><span class="line">    done</span><br><span class="line">    echo</span><br><span class="line">let x+=1,y=1</span><br><span class="line">done</span><br></pre></td></tr></table></figure>



<p>19、后续六个字符串：efbaf275cd、4be9c40b8b、44b2395c46、f8c8873ce0、b902c16c8b、ad865d2f63是通过对随机数变量RANDOM随机 执行命令：   echo $RANDOM|md5sum|cut –c1-10    后的结果，请破解这些 字符串对应的RANDOM值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">  ch=(efbaf275cd 4be9c40b8b 44b2395c46 f8c8873ce0 b902c16c8b ad865d2f63)</span><br><span class="line">  for num in `seq 0 65535`;do</span><br><span class="line">      chnum=`echo $num | md5sum | cut -c 1-10`</span><br><span class="line">     for n in  $&#123;ch[*]&#125;; do</span><br><span class="line">          if [ "$chnum" == "$n" ];then</span><br><span class="line">              echo "$n --&gt; $num" </span><br><span class="line">          fi</span><br><span class="line">      done</span><br><span class="line">  done</span><br></pre></td></tr></table></figure>



<p>20、每隔3秒钟到系统上获取已经登录的用户的信息；如果发现用户hacker登录， 则将登录时间和主机记录于日志/var/log/login.log中,并退出脚本 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">username=cent</span><br><span class="line">&#123;</span><br><span class="line">while true ;do</span><br><span class="line">    if who | egrep "^\b$username\b" &amp;&gt; /dev/null ;then</span><br><span class="line">        who | egrep "^\b$username\b" &gt;&gt; /var/log/login.log</span><br><span class="line">        echo "$username 已经登录"</span><br><span class="line">        echo "fuck ,go out my system" | write $username</span><br><span class="line">    else</span><br><span class="line">        echo "$username 已经下线"</span><br><span class="line">    fi</span><br><span class="line">    sleep 3</span><br><span class="line">done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>21、随机生成10以内的数字，实现猜字游戏，提示比较大或小，相等则退出 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!bin/bash</span></span><br><span class="line">lim=10</span><br><span class="line">let key=$RANDOM%lim</span><br><span class="line">read -p  "please input a number less than $lim: " num</span><br><span class="line">until false;do</span><br><span class="line">    if [ $num -le $lim &amp;&gt; /dev/null  ] &amp;&amp; [ $num -ge 0  &amp;&gt; /dev/null ] ;then</span><br><span class="line">        if [ $num -lt $key ];then</span><br><span class="line">            read -p "is small,please input again: " num</span><br><span class="line">        elif [ $num -gt $key ];then</span><br><span class="line">            read -p "is big,please input again: " num</span><br><span class="line">        else</span><br><span class="line">            echo "you are right,you are very clever"</span><br><span class="line">            break</span><br><span class="line">        fi</span><br><span class="line">    else</span><br><span class="line">        read -p  "error,please input a number less than ten: " num</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>



<p>22、用文件名做为参数，统计所有参数文件的总行数 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">let z=0</span><br><span class="line">while read -p "please input file path: " n</span><br><span class="line">do</span><br><span class="line">        m=`cat "$n" | wc -l`</span><br><span class="line">        z=$[$z+$m]</span><br><span class="line">        echo "sum line: $z"</span><br><span class="line">        if (("$z" &gt; "5000"))</span><br><span class="line">        then</span><br><span class="line">                echo "cache will be full"</span><br><span class="line">                break</span><br><span class="line">        fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>



<p>23、用二个以上的数字为参数，显示其中的最大值和最小值 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">while read -p "please input two number: " n m</span><br><span class="line">do</span><br><span class="line">        if (("$n" &gt; "$m"))</span><br><span class="line">                then</span><br><span class="line">                max=$[$n]</span><br><span class="line">                min=$[$m]</span><br><span class="line">                echo "max=$max; min=$min"</span><br><span class="line">        elif (("$n" &lt; "$m"))</span><br><span class="line">                then</span><br><span class="line">                max=$[$m]</span><br><span class="line">                min=$[$n]</span><br><span class="line">                echo "max=$max; min=$min"       </span><br><span class="line">        else</span><br><span class="line">                echo "two num equal"</span><br><span class="line">        fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>



<p>24.编写函数，实现OS的版本判断 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">os () &#123;</span><br><span class="line">        osname=`sed -r 's/.* ([0-9])\..*/\1/' /etc/redhat-release`</span><br><span class="line">        echo "$osname"</span><br><span class="line">&#125;</span><br><span class="line">        echo "os version is `os`"</span><br></pre></td></tr></table></figure>




<p>25编写函数，实现取出当前系统eth0的IP地址 </p>
<p>​    </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">	read -p "please input you want to find: " n</span><br><span class="line">	net () &#123;</span><br><span class="line">	        ifconfig $n &amp;&gt; /dev/null</span><br><span class="line">	        if [ "$?" -ne "0" ]</span><br><span class="line">	                then</span><br><span class="line">	                        echo "net do not have"</span><br><span class="line">	        else</span><br><span class="line">	                ip=`ifconfig $n | grep netmask | awk '&#123;print $2&#125;'`</span><br><span class="line">	                echo "ip is : $ip"</span><br><span class="line">	        fi</span><br><span class="line">	&#125;</span><br><span class="line">net</span><br></pre></td></tr></table></figure>

<p>26.编写函数，实现打印绿色OK和红色FAILED </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">./etc/init.d/functions</span><br><span class="line">action "success!" true</span><br><span class="line">action "failed"   false</span><br></pre></td></tr></table></figure>

<p>27编写函数，实现判断是否无位置参数，如无参数，提示错误</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line">args () &#123;</span><br><span class="line">      if [ $# -eq 0 ];then</span><br><span class="line">       . /etc/init.d/functions</span><br><span class="line">       action "fail... you must input a parameter" false</span><br><span class="line">      fi</span><br><span class="line">&#125;</span><br><span class="line">args $1</span><br></pre></td></tr></table></figure>





<ol start="28">
<li>编写服务脚本/root/bin/testsrv.sh，完成如下要求<br>(1) 脚本可接受参数：start, stop, restart, status<br>(2) 如果参数非此四者之一，提示使用格式后报错退出<br>(3) 如是start:则创建/var/lock/subsys/SCRIPT_NAME, 并显示“启动成功” 考虑：如果事先已经启动过一次，该如何处理？<br>(4) 如是stop:则删除/var/lock/subsys/SCRIPT_NAME, 并显示“停止完成” 考虑：如果事先已然停止过了，该如何处理？<br>(5) 如是restart，则先stop, 再start 考虑：如果本来没有start，如何处理？<br>(6) 如是status, 则如果/var/lock/subsys/SCRIPT_NAME文件存在，则显示“SCRIPT_NAME is running…” 如果/var/lock/subsys/SCRIPT_NAME文件不存在，则显示“SCRIPT_NAME is stopped…” 其中：SCRIPT_NAME为当前脚本名<br>(7)在所有模式下禁止启动该服务，可用chkconfig 和 service命令管理</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">chkconfig:- 96 07</span></span><br><span class="line"><span class="meta">#</span><span class="bash">description</span></span><br><span class="line">[ -f /etc/rc.d/init.d/`basename $0` ]||mv /app/script/`basename $0` /etc/rc.d/init.d/`basename $0`&amp;&gt;/dev/null</span><br><span class="line">chkconfig --add `basename $0`</span><br><span class="line">sta () &#123;</span><br><span class="line">             touch /var/lock/subsys/`basename $0`</span><br><span class="line">             . /etc/init.d/functions</span><br><span class="line">             action "`basename $0` start successful!" true</span><br><span class="line">&#125;</span><br><span class="line">sto () &#123;</span><br><span class="line">         rm /var/lock/subsys/`basename $0`</span><br><span class="line">              . /etc/init.d/functions</span><br><span class="line">             action "`basename $0` is stopped" true</span><br><span class="line">&#125;</span><br><span class="line">rest () &#123;</span><br><span class="line">         sto</span><br><span class="line">         sta</span><br><span class="line">&#125;</span><br><span class="line">statu () &#123;</span><br><span class="line">            if [ -f /var/lock/subsys/`basename $0` ];then</span><br><span class="line">                   . /etc/init.d/functions</span><br><span class="line">                    action "`basename $0` is running" true</span><br><span class="line">             else</span><br><span class="line">                      action "`basename $0` is stopped" true</span><br><span class="line">            fi</span><br><span class="line">&#125;</span><br><span class="line">case $1 in</span><br><span class="line">start)</span><br><span class="line">          if [ -f /var/lock/subsys/`basename $0` ];then</span><br><span class="line">                    echo "`basename $0` is running"</span><br><span class="line">           else</span><br><span class="line">                 sta</span><br><span class="line">          fi</span><br><span class="line">                        ;;</span><br><span class="line">stop)</span><br><span class="line">             if [ -f /var/lock/subsys/`basename $0` ];then</span><br><span class="line">                        sto</span><br><span class="line">             else</span><br><span class="line">                    echo "`basename $0` has been stopped before"</span><br><span class="line">            fi</span><br><span class="line">                     ;;</span><br><span class="line">restart)</span><br><span class="line">         if  [ -f /var/lock/subsys/`basename $0` ];then</span><br><span class="line">                        sto</span><br><span class="line">                        sta</span><br><span class="line">           else</span><br><span class="line">                   sta</span><br><span class="line">            fi</span><br><span class="line">                    ;;</span><br><span class="line">status)</span><br><span class="line">               statu</span><br><span class="line">               ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>



<p>29.编写脚本/root/bin/copycmd.sh<br>    (1) 提示用户输入一个可执行命令名称<br>    (2) 获取此命令所依赖到的所有库文件列表<br>    (3) 复制命令至某目标目录(例如/mnt/sysroot)下的对应路径下       如：/bin/bash ==&gt; /mnt/sysroot/bin/bash  /usr/bin/passwd ==&gt; /mnt/sysroot/usr/bin/passwd<br>    (4) 复制此命令依赖到的所有库文件至目标目录下的对应路径下：  如：/lib64/ldlinux-x86-64.so.2 ==&gt; /mnt/sysroot/lib64/ld-linux-x86-64.so.2<br>    (5)每次复制完成一个命令后，不要退出，而是提示用户键入新的要复制的命令， 并重复完成上述功能；直到用户输入quit退出 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">	read -p "please input a excute cmd(eg:cat|bash|quit):" command</span><br><span class="line">	[ -a /mnt/sysroot ]||mkdir /mnt/sysroot &amp;&gt;/dev/null</span><br><span class="line">	cpdir () &#123;</span><br><span class="line">	      cmd=`which --skip-alias $command`</span><br><span class="line">	      if [ -f  /mnt/sysroot$cmd ];then</span><br><span class="line">	           echo "the $cmd has been cp before"</span><br><span class="line">	       else</span><br><span class="line">	       local dir=`dirname $cmd`</span><br><span class="line">	         mkdir -p /mnt/sysroot$dir</span><br><span class="line">	         cp $cmd /mnt/sysroot$cmd</span><br><span class="line">	                echo "cp $cmd finished"</span><br><span class="line">	          fi</span><br><span class="line">	&#125;</span><br><span class="line">	cplib () &#123;</span><br><span class="line">	          cmd=`which --skip-alias $command`</span><br><span class="line">	          ldd $cmd |egrep -o "/lib64.* "|while read i;do</span><br><span class="line">	            if  [ ! -f /mnt/sysroot$i ];then</span><br><span class="line">	            local dir=`dirname $i`</span><br><span class="line">	             mkdir -p /mnt/sysroot$dir</span><br><span class="line">	                cp $i /mnt/sysroot$i     </span><br><span class="line">	                    echo "cp $i  finished"</span><br><span class="line">	            else</span><br><span class="line">	                   echo "$i has been cp before"</span><br><span class="line">	             fi</span><br><span class="line">	            done</span><br><span class="line">	&#125;</span><br><span class="line">	type $command&amp;&gt;/dev/null||&#123; echo the command is not exsit;exit 100; &#125;</span><br><span class="line">	until [ $command == quit ];do</span><br><span class="line">	type $command&amp;&gt;/dev/null||&#123; echo the command is not exsit;exit 100; &#125;</span><br><span class="line">	cpdir</span><br><span class="line">	cplib</span><br><span class="line">	read -p "please input new excute cmd(eg:cat|bash|quit):" command</span><br><span class="line">	cmd=`which --skip-alias $command`</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>



<p>30.编写函数实现两个数字做为参数，返回最大值 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">/app/f1</span></span><br><span class="line">max () &#123;</span><br><span class="line">        [ $# -ne 2 ]&amp;&amp;echo "you must input two number"&amp;&amp;exit 10</span><br><span class="line">        until [ $# -eq 0 ];do</span><br><span class="line">               echo $1 &gt;&gt;/app/f1  </span><br><span class="line">                 shift</span><br><span class="line">        done</span><br><span class="line">               sort -nr /app/f1|head -n1</span><br><span class="line">&#125;</span><br><span class="line">max $*</span><br></pre></td></tr></table></figure>





<p>31.斐波那契数列又称黄金分割数列，因数学家列昂纳多·斐波那契以兔子繁殖为例 子而引入，<br>    故又称为“兔子数列”，指的是这样一个数列：0、1、1、2、3、5、 8、13、21、34、……，斐波纳契数列以如下被以递归的方法定义：F（0）=0， F（1）=1，F（n）=F(n-1)+F(n-2)（n≥2）     利用函数，求n阶斐波那契数列 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash <span class="comment"># </span></span></span><br><span class="line">read -p "请输入斐波那契数列的阶数：" n </span><br><span class="line">func1 () &#123; </span><br><span class="line">if [ $1 -eq 0 ];then </span><br><span class="line">echo 0 </span><br><span class="line">elif [ $1 -eq 1 ];then </span><br><span class="line">echo 1</span><br><span class="line"> else </span><br><span class="line">echo $[`func1 $[$1-1]`+`func1 $[$1-2]`] </span><br><span class="line">fi &#125; </span><br><span class="line">for i in `seq 0 $n`;do </span><br><span class="line">func1 $i </span><br><span class="line">done</span><br></pre></td></tr></table></figure>


<p>​<br>32.汉诺塔（又称河内塔）问题是源于印度一个古老传说。大梵天创造世界的时候做 了三根金刚石柱子，<br>​    在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。 大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且 规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘，利用 函数，实现N片盘的汉诺塔的移动步骤  </p>
<p>​        </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">function ta()</span><br><span class="line">&#123;</span><br><span class="line">        if [ $1 -eq 1 ];then</span><br><span class="line">                echo " move $2 -----&gt; $4 "</span><br><span class="line">        else</span><br><span class="line">                ta $(($1-1)) $2 $4 $3</span><br><span class="line">                echo " move $2 -----&gt; $4"</span><br><span class="line">                ta $(($1-1)) $3 $2 $4</span><br><span class="line">        fi</span><br><span class="line">&#125;</span><br><span class="line">ta $1 '1' '2' '3'</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>lvs常见几种模式</title>
    <url>/2020/06/27/lvs%E5%B8%B8%E8%A7%81%E5%87%A0%E7%A7%8D%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="lvs常见几种模式"><a href="#lvs常见几种模式" class="headerlink" title="lvs常见几种模式"></a>lvs常见几种模式</h1><h2 id="一-基础介绍"><a href="#一-基础介绍" class="headerlink" title="一.基础介绍"></a>一.基础介绍</h2><p>  </p>
<p>  LVS是Linux虚拟服务(Linux Virtual Server)的简称，是一个虚拟的服务器集群系统，是国内最早的一批自由软件项目，由章文嵩博士发起。现在LVS项目已经被Linux内核收录，成为Linux表针内核的一个重要组成部分。<a id="more"></a></p>
<p>  随着互联网大潮的不断发展，纵向拓展的高额成本和逐渐降低的性能提升不足以满足用户的正常访问，因此横向拓展便成为主要的发展方向。通过使用LVS提供的负载均衡技术和Linux操作系统进而实现一个高性能，高可用的服务器集群，它具有着良好的可靠性，可拓展性和可操作性，从而能够以较低廉的成本价格来提供更好的性能提升。</p>
<p>  LVS项目自从1998年提出开始，随机不断的发展，现在已经成为了一个相当成熟的技术项目。可以利用LVS技术来实现高度的可伸缩性和高可用性的网络服务；有效的可管理性提供了便捷的异地管理主机；价格的有效性实现了整个系统的经济性和成本的可控性。</p>
<p>  </p>
<p>​      </p>
<h2 id="二-LVS的结构"><a href="#二-LVS的结构" class="headerlink" title="二.LVS的结构"></a>二.LVS的结构</h2><p>  </p>
<p>  LVS构建的集群系统大致可分为三个部分组成：前端的负载均衡层，中间的服务器集群层和最底层的共享数据层。负载调度器能够无缝隙的将网络请求调度到后端的真实提供服务的服务器上，从而使得服务器集群的结构是透明的，用户在访问整个集群的服务时就像是在访问一台高性能，高可用性的真实服务器一样。客户端的程序不会受到服务器集群的修改而受到影响，服务器集群的可伸缩性在于可以通过向集群中加入或者删除节点来实现，通过对应的节点故障检测和系统重置可以实现高度的可用性。</p>
<p>​      </p>
<p>  </p>
<h3 id="LVS体系图例"><a href="#LVS体系图例" class="headerlink" title="LVS体系图例"></a>LVS体系图例</h3><p>​                <img src="https://s4.51cto.com/images/blog/201805/20/16f690048a3c88ddc2fd8c4c7d83fc78.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt=""></p>
<p>​                 </p>
<p>​                  </p>
<h3 id="LVS各层次的具体划分"><a href="#LVS各层次的具体划分" class="headerlink" title="LVS各层次的具体划分"></a>LVS各层次的具体划分</h3><p>  负载均衡层：</p>
<p>    处于整个集群的最前端，由一台或者多台调度器构成，LVS模块部署在调度器上，调度器根据既定的算法来实现将网络请求调度到不同后端服务器，完成对应的功能。</p>
<p>  </p>
<p>  服务器集群层：</p>
<p>    由一组实际运行着应用服务的服务器构成，后端服务器支持的服务包括，web服务，邮件服务，FTP服务，DNS服务等一个或者多个，每个服务器之间可以通过LAN或者更大范围的WAN相连，在实际的应用场景中，调取服务器也可以作为应用服务器提供服务。</p>
<p>  </p>
<p>  共享数据层：</p>
<p>    向服务器集群中的所有real server提供共享存储空间和内容一致性的存储区域。一般是由磁盘阵列组成，提供数据的一致性。也可以由NFS提供。目前来说磁盘阵列更为适合，NFS受网络影响较大，不太稳定。</p>
<p>​                </p>
<p>注意：调度器在整个LVS体修中最为关键，是整个系统的核心部分。目前来说调度器系统仅仅支持Linux，内核2.6之后已经无需设置就原生支持LVS，但是reasl server的系统并不受限制，大多数常见的系统均可作为应用服务器提供服务。</p>
<p>  </p>
<p>  </p>
<h2 id="三-负载均衡技术与LVS调度机制"><a href="#三-负载均衡技术与LVS调度机制" class="headerlink" title="三.负载均衡技术与LVS调度机制"></a>三.负载均衡技术与LVS调度机制</h2><p>  </p>
<p>  当前负载均衡技术有很多实现方案，例如基于DNS域名依次轮流解析、基于客户端调度访问、基于应用层系统负载的调度，还有基于IP地址的调度等，相比较而言IP负载均衡技术更为成熟和效率。LVS的IP负载均衡技术是依赖于ipvs内核模块来实现的，ipvs是LVS集群系统的核心软件，它的主要作用是：安装在调度器上，同时在调度器上虚拟出一个IP地址（这个地址可以正常访问互联网），用户必须通过这个虚拟的IP地址访问集群服务。这个虚拟IP一般称为LVS的VIP。访问的请求首先经过VIP到达负载调度器，然后由负载调度器从Real Server列表中根据不同的调度算法计算选取一个服务节点响应用户的请求。</p>
<p>  </p>
<h4 id="常用的调度机制"><a href="#常用的调度机制" class="headerlink" title="常用的调度机制"></a>常用的调度机制</h4><p>  </p>
<p>  VS/NAT机制（Virtual Server via Network Address Translation）</p>
<p>  通过网络地址转换技术。当用户的请求报文发送到调度器时，调度器重写请求报文的目标地址为调度器通过算法得出的后端real server的IP地址，同时请求报文的目标端口号也会被重写为后端服务器提供服务的端口号，之后将重新构建的报文分派给后端的真实服务器；真实服务器的在返回数据报文给用户时，响应报文在通过调度器时，调度器会再次将报文的源地址和源端口重写为虚拟IP地址和端口，再返回给客户，完成整个负载调度过程。</p>
<p><img src="https://s4.51cto.com/images/blog/201805/20/45a285f3cee6c0a763233a7365c80b28.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt=""></p>
<p>​        多目标的DNAT(iptables)；它通过修改请求报文的目标IP地址(同时可能会修改目标端口)至挑选出某RS的RIP地址实现转发；</p>
<p>  </p>
<p>注意：</p>
<p>    (1) RS应该和DIP应该使用私网地址，且RS的网关要指向DIP；</p>
<p>    (2) 请求和响应报文都要经由director转发；极高负载的场景中，director可能会成为系统瓶颈；</p>
<p>    (3) 支持端口映射；</p>
<p>    (4) RS可以使用任意操作系统；</p>
<p>    (5) RS的RIP和Director的DIP必须在同一IP网络；</p>
<p>  </p>
<p>  VS/TUN机制（Virtual Server via IP Tunneling）</p>
<p>  采用NAT技术时，由于请求和响应报文都必须经过调度器地址重写，当客户请求越来越多时，调度器的处理能力将成为瓶颈。采用IP隧道技术实现LVS，它的调度方法与NAT方式一样，但是TUN的报文转发方式不同，TUN方式中，调度器使用IP隧道技术将用户的请求转发到某个real server上，这个real server可以直接通过网络响应用户的请求，不必经过调度器再次调度，因此调度器和real server的地域限制不再存在，可以与调度器在同一网段，也可以在不同的网络中。因此，在TUN中调度器仅仅负责处理用户的报文请求，而不必处理响应报文，采用 VS/TUN技术后，集群系统的最大吞吐量可以提高10倍。</p>
<p><img src="https://s4.51cto.com/images/blog/201805/20/a10f448a030f5335c687736d0c3c53b3.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt=""></p>
<p>注意：</p>
<p>  TUN不修改请求报文的ip首部，而是通过在原有的ip首部（cip&lt;–&gt;vip）之外，再封装一个ip首部&amp;(dip&lt;–&gt;rip)；</p>
<p>    (1) RIP, DIP, VIP全得是公网地址；</p>
<p>    (2) RS的网关的不能指向DIP；</p>
<p>    (3) 请求报文必须经由director调度，但响应报文必须不能经由director；</p>
<p>    (4) 不支持端口映射；</p>
<p>    (5) RS的OS必须支持隧道功能；</p>
<p>  </p>
<p>  </p>
<p>  VS/DR(Virtual Server via Direct Routing)</p>
<p>  通过直接路由技术构建，调度和管理与之前两个相同，但是报文的转发方式不同，DR模型通过修改请求报文的MAC地址，将请求发送到real server上，real server在完成请求后直接将响应回应给用户，减少了IP隧道的成本，也不必要求必须支持隧道协议；但是要求调度器和real server都有一块网卡在同一物理网络中。同样DR模型也可以极大地 提高集群系统的伸缩性。</p>
<p><img src="https://s4.51cto.com/images/blog/201805/20/22712140097c2e0961b6261936c6a509.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt=""></p>
<p>  </p>
<p>注意：</p>
<p>  (1) 保证前端路由器将目标IP为VIP的请求报文发送给director; </p>
<p>    解决方案：</p>
<p>    静态绑定 </p>
<p>    arptables</p>
<p>    修改RS主机内核的参数</p>
<p>  (2) RS的RIP可以使用私有地址；但也可以使用公网地址；</p>
<p>  (3) RS跟Director必须在同一物理网络中 ；</p>
<p>  (4) 请求报文经由Director调度，但响应报文一定不能经由Director；</p>
<p>  (5) 不支持端口映射；</p>
<p>  (6) RS可以大多数OS；</p>
<p>  (7) RS的网关不能指向DIP；</p>
<p>  </p>
<h2 id="四-调度算法"><a href="#四-调度算法" class="headerlink" title="四.调度算法"></a>四.调度算法</h2><p><strong>静态方法</strong>：仅根据算法本身进行调度； </p>
<p>  RR：round robin，轮叫</p>
<p>  “轮叫”调度也叫作“1:1”调度，调度器通过“轮叫”调度算法将外部用户请求顺序按照顺序1:1的分配到集群中的每个real server上，这种算法平等的对待每一台real server，不考虑不同机器的性能差异与系统当前的负载情况。</p>
<p>  WRR：weighted rr, 加权轮叫</p>
<p>  加权轮叫算法是根据real server的不同的处理性能来调度访问请求，可以对每台real server设置不同的权重值，对于性能好的机器可以设置较高的去权重值，而对于性能较弱的机器，设置较低的权重值，这样可以保证性能强的机器能够分配到较多的用户请求，性能较差的机器分配较少的用户请求，合理的利用现有的资源，同时，调度器还可以自动查询real server的负载情况，动态的进行权重来进行合理的分配资源。</p>
<p>  SH: source hash, 实现session保持的机制；将来自于同一个IP的请求始终调度至同一RS；</p>
<p>  “源地址散列“调度算法根据用户请求的来源地址，作为散列键（Hash key）从静态分配的散列表内找出相对应的服务器，若被找出的服务器是可用且未超载，则调度器将请求发送到这台服务器否则返回空。</p>
<p>  DH：destination hash, 将对同一个目标的请求始终发往同一个RS；</p>
<p>  “目标地址散列”调度算法，调度器根据请求的目标IP地址，作为散列键从静态分配的散列表中找出对应的服务器，若被找出的服务器是可用且未超载，则将请求发送到这台服务器。</p>
<p>  </p>
<p><strong>动态方法</strong>：根据算法及各RS的当前负载状态进行调度；</p>
<p>    Overhead=当前负载状态</p>
<p>  LC：Least Connection   最少连接数</p>
<p>    Overhead=Active*256+Inactive</p>
<p>  “最少连接数”调度算法动态的将网络请求调度到已经建立的连接数最少服务器上，假设集群中的服务器都具有相近的运算性能，那么使用“最小连接数”调度算法可以很好的去均衡集群的负载。</p>
<p>  WLC: Weighted LC  加权最少连接</p>
<p>    Overhead=(Active*256+Inactive)/weight</p>
<p>  “加权最少连接”调度算法是“最少连接”算法的进一步优化，每个处理节点可以设置不同的权重值来表示其不同的处理性能，网络管理人员可以动态调整这些权值。默认值是1.加权最小连接调度算法在调度时候尽可能的去调度服务节点与权重值成正向比例。</p>
<p>  SED: Shortest Expection Delay   最短期望延迟</p>
<p>    Overhead=(Active+1)*256/weight</p>
<p>  NQ：Never Queue  永不排队</p>
<p>  “永不排队”调度算法在负载较低时，会将请求直接分配到空闲的服务器之上，不会进行额外的算法调度，当整个集群负载较高时，则会进行轮叫。</p>
<p>    SED算法的改进；</p>
<p>  LBLC：Locality-Based LC，即为动态的DH算法；</p>
<p>    正向代理情形下的cache server调度；</p>
<p>  “基于局部的最少连接”调度算法，本质上是为了实现基于目标IP地址的负载均衡。这个算法根据请求的目标IP地址找出该目标IP地址最近使用的服务器，若该服务器可用且未超载，那么进行调度；假如服务器不存在，或者该服务器超载且有服务器处于一半的工作负载，则用”最少链接”的原则选出一个可用的服务 器，将请求发送到该服务器。</p>
<p>  LBLCR：Locality-Based Least-Connection with Replication，带复制功能的LBLC算法；</p>
<p>  “带复制的基于局部性最少链接”调度算法也是针对目标IP地址的负载均衡，应用与LBLC相同，不同之处是它要维护从一个 目标IP地址到一组服务器的映射，而LBLC算法维护从一个目标IP地址到一台服务器的映射。该算法根据请求的目标IP地址找出该目标IP地址对应的服务 器组，按”最小连接”原则从服务器组中选出一台服务器，若服务器没有超载，将请求发送到该服务器，若服务器超载；则按”最小连接”原则从这个集群中选出一 台服务器，将该服务器加入到服务器组中，将请求发送到该服务器。同时，当该服务器组有一段时间没有被修改，将最忙的服务器从服务器组中删除，以降低复制的程度。</p>
<h2 id="五-LVS适用环境与安装使用"><a href="#五-LVS适用环境与安装使用" class="headerlink" title="五.LVS适用环境与安装使用"></a>五.LVS适用环境与安装使用</h2><p>  </p>
<p><strong>适用环境</strong></p>
<p>  调度器目前支持Linuxhe FreeBSD</p>
<p>  支持的TCP：HTTP,HTTPS,FTP,SMTP,POP3,IMAP4,PROXY,LDAP,SSMTP</p>
<p>  支持的UDP：DNS,NTP,ICP,视频和音频流播放协议。</p>
<p>  </p>
<p>  LVS对应real server没有限制，real server可以运行在所有的支持TCP/IP的操作系统之上。</p>
<p>  </p>
<p><strong>管理软件ipvsadm与常见配置选项</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install ipvsadm -y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">管理集群服务</span><br><span class="line"></span><br><span class="line">  ipvsadm -A|E -t|u|f service-address [-s scheduler]</span><br><span class="line"></span><br><span class="line">  ipvsadm -D -t|u|f service-address</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  service-address:</span><br><span class="line"></span><br><span class="line">    tcp: -t ip:port</span><br><span class="line"></span><br><span class="line">    udp: -u ip:port</span><br><span class="line"></span><br><span class="line">    fwm: -f mark</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  -s scheculer:</span><br><span class="line"></span><br><span class="line">    默认为wlc</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  管理集群服务中的RS</span><br><span class="line"></span><br><span class="line">  ipvsadm -a|e -t|u|f service-address -r server-address [-g|i|m] [-w weight]</span><br><span class="line"></span><br><span class="line">  ipvsadm -d -t|u|f service-address -r server-address</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  server-address: </span><br><span class="line"></span><br><span class="line">  ip[:port]</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  lvs-type:</span><br><span class="line"></span><br><span class="line">  -g: gateway, dr</span><br><span class="line"></span><br><span class="line">  -i: ipip, tun</span><br><span class="line"></span><br><span class="line">  -m: masquerade, nat</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  清空和查看：</span><br><span class="line"></span><br><span class="line">  ipvsadm -C</span><br><span class="line"></span><br><span class="line">  ipvsadm -L|l [options]    </span><br><span class="line"></span><br><span class="line">    -n: numeric，基于数字格式显示地址和端口；</span><br><span class="line"></span><br><span class="line">    -c: connection，显示ipvs连接；</span><br><span class="line"></span><br><span class="line">    --stats：统计数据</span><br><span class="line"></span><br><span class="line">    --rate: 速率</span><br><span class="line"></span><br><span class="line">    --exact: 精确值        </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  保存和重载：</span><br><span class="line"></span><br><span class="line">  ipvsadm -R</span><br><span class="line"></span><br><span class="line">  ipvsadm -S [-n]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  置零计数器：</span><br><span class="line"></span><br><span class="line">  ipvsadm -Z [-t|u|f service-address]</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  注释：</span><br><span class="line"></span><br><span class="line">​        -A    添加一个新的集群服务；</span><br><span class="line"></span><br><span class="line">​        -E    修改一个己有的集群服务；</span><br><span class="line"></span><br><span class="line">​        -D    删除指定的集群服务；</span><br><span class="line"></span><br><span class="line">​        -a    向指定的集群服务中添加RS及属性；</span><br><span class="line"></span><br><span class="line">​        -e    修改RS属性；</span><br><span class="line"></span><br><span class="line">​        -t    指定为tcp协议；</span><br><span class="line"></span><br><span class="line">​        -u    指定为udp协议；</span><br><span class="line"></span><br><span class="line">​        -f    指定防火墙标记码，通常用于将两个或以上的服务绑定为一个服务进行处理时使用；</span><br><span class="line"></span><br><span class="line">​        -s    调度方法，默认为wlc；</span><br><span class="line"></span><br><span class="line">​        -w    指定权重，默认为1；</span><br><span class="line"></span><br><span class="line">​        -p timeout   persistent connection, 持久连接超时时长；</span><br><span class="line"></span><br><span class="line">​        -g    Gateway, DR模型；</span><br><span class="line"></span><br><span class="line">​        -i    ipip, TUN模型；</span><br><span class="line"></span><br><span class="line">​        -m    masquerade, NAT模型；</span><br><span class="line"></span><br><span class="line">​        -S    保存ipvsadm设定的规则策略，默认保存在/etc/sysconfig/ipvsadm中；</span><br><span class="line"></span><br><span class="line">​        -R    载入己保存的规则策略，默认加载/etc/sysconfig/ipvsadm；</span><br><span class="line"></span><br><span class="line">​        -C    清除所有集群服务；</span><br><span class="line"></span><br><span class="line">​        -Z    清除所有记数器；</span><br><span class="line"></span><br><span class="line">​        -L    显示当前己有集群服务，能通过相应的options查看不同状态信息；</span><br></pre></td></tr></table></figure>

<p>  </p>
<p>​    </p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>filebeat入门</title>
    <url>/2020/06/28/filebeat%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="filebeat入门"><a href="#filebeat入门" class="headerlink" title="filebeat入门"></a>filebeat入门</h1><p><img src="/.online//QQ20200628-001622@2x.png" alt></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>ELK</tag>
        <tag>filebeat</tag>
      </tags>
  </entry>
</search>
